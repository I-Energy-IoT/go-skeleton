package logger

import (
	"context"
	"errors"
	"fmt"
	"math"
	"os"

	"{{.Name}}/config"

	"go.uber.org/fx"
	"go.uber.org/fx/fxevent"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

// Module provides the logger dependency injection module
var Module = fx.Options(
	fx.Provide(NewLogger),
)

// Logger defines the interface for structured logging operations
type Logger interface {
	// WithField adds a single field to the logger context
	WithField(key string, value interface{}) Logger
	// WithFields adds multiple fields to the logger context
	WithFields(fields map[string]interface{}) Logger
	// WithError adds an error to the logger context
	WithError(err error) Logger
	// WithErrorStr adds an error string to the logger context
	WithErrorStr(errStr string) Logger
	// WithContext adds context information to the logger
	WithContext(ctx context.Context) Logger
	// WithInput adds input data to the logger context
	WithInput(input interface{}) Logger
	// WithOutput adds output data to the logger context
	WithOutput(output interface{}) Logger
	// WithResponseTime adds response time in milliseconds to the logger context
	WithResponseTime(responseTime float64) Logger
	// WithKeyword adds a keyword to the logger context
	WithKeyword(keyword string) Logger
	// WithURL adds a URL to the logger context
	WithURL(url string) Logger
	// WithStatusCode adds an HTTP status code to the logger context
	WithStatusCode(code int) Logger

	// Debug logs a debug message with optional fields
	Debug(msg string, fields ...zap.Field)
	// Info logs an info message with optional fields
	Info(msg string, fields ...zap.Field)
	// Warn logs a warning message with optional fields
	Warn(msg string, fields ...zap.Field)
	// Error logs an error message with optional fields
	Error(msg string, fields ...zap.Field)
	// Fatal logs a fatal message and exits the program
	Fatal(msg string, fields ...zap.Field)
	// LogEvent logs UberFX lifecycle events
	LogEvent(event fxevent.Event)
}

// standardLogger implements the Logger interface using zap
type standardLogger struct {
	zapLogger *zap.Logger
}

// NewLogger creates a new logger instance based on configuration
func NewLogger(cfg *config.Config) (Logger, error) {
	var zapCfg zap.Config

	if cfg.IsProduction() {
		zapCfg = zap.NewProductionConfig()
		zapCfg.Level = zap.NewAtomicLevelAt(zap.InfoLevel)
		zapCfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
		zapCfg.EncoderConfig.EncodeLevel = zapcore.LowercaseLevelEncoder
	} else if cfg.IsDevelopment() {
		zapCfg = zap.NewDevelopmentConfig()
		zapCfg.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
		zapCfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
		zapCfg.Level = zap.NewAtomicLevelAt(zap.DebugLevel)
	} else if cfg.IsStaging() {
		zapCfg = zap.NewProductionConfig()
		zapCfg.Level = zap.NewAtomicLevelAt(zap.DebugLevel)
		zapCfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
		zapCfg.EncoderConfig.EncodeLevel = zapcore.LowercaseLevelEncoder
	} else if cfg.IsUAT() {
		zapCfg = zap.NewDevelopmentConfig()
		zapCfg.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
		zapCfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
		zapCfg.Level = zap.NewAtomicLevelAt(zap.InfoLevel)
	}

	// Configure output paths
	zapCfg.OutputPaths = []string{"stdout"}
	if cfg.IsProduction() {
		zapCfg.OutputPaths = append(zapCfg.OutputPaths, "stderr")
	}

	// Build the logger with caller skip for better stack traces
	logger, err := zapCfg.Build(
		zap.AddCallerSkip(1),
		zap.AddStacktrace(zap.ErrorLevel),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to build logger: %w", err)
	}

	// Replace global logger for compatibility
	zap.ReplaceGlobals(logger)

	return &standardLogger{zapLogger: logger}, nil
}

// WithField adds a single field to the logger context
func (l *standardLogger) WithField(key string, value interface{}) Logger {
	return &standardLogger{zapLogger: l.zapLogger.With(zap.Any(key, value))}
}

// WithFields adds multiple fields to the logger context
func (l *standardLogger) WithFields(fields map[string]interface{}) Logger {
	zapFields := make([]zap.Field, 0, len(fields))
	for k, v := range fields {
		zapFields = append(zapFields, zap.Any(k, v))
	}
	return &standardLogger{zapLogger: l.zapLogger.With(zapFields...)}
}

// WithError adds an error to the logger context
func (l *standardLogger) WithError(err error) Logger {
	if err == nil {
		return l
	}
	return &standardLogger{zapLogger: l.zapLogger.With(zap.Error(err))}
}

// WithErrorStr adds an error string to the logger context
func (l *standardLogger) WithErrorStr(errStr string) Logger {
	if errStr == "" {
		return l
	}
	return &standardLogger{zapLogger: l.zapLogger.With(zap.Error(errors.New(errStr)))}
}

// WithContext adds context information to the logger
func (l *standardLogger) WithContext(ctx context.Context) Logger {
	if ctx == nil {
		return l
	}
	return l.WithField("context", ctx)
}

// WithInput adds input data to the logger context
func (l *standardLogger) WithInput(input interface{}) Logger {
	return l.WithField("input", input)
}

// WithOutput adds output data to the logger context
func (l *standardLogger) WithOutput(output interface{}) Logger {
	return l.WithField("output", output)
}

// WithResponseTime adds response time in milliseconds to the logger context
func (l *standardLogger) WithResponseTime(responseTime float64) Logger {
	return &standardLogger{zapLogger: l.zapLogger.With(zap.Int("response_time_ms", int(math.Round(responseTime))))}
}

// WithKeyword adds a keyword to the logger context
func (l *standardLogger) WithKeyword(keyword string) Logger {
	return l.WithField("keyword", keyword)
}

// WithURL adds a URL to the logger context
func (l *standardLogger) WithURL(url string) Logger {
	return l.WithField("url", url)
}

// WithStatusCode adds an HTTP status code to the logger context
func (l *standardLogger) WithStatusCode(code int) Logger {
	return &standardLogger{zapLogger: l.zapLogger.With(zap.Int("status_code", code))}
}

// Debug logs a debug message with optional fields
func (l *standardLogger) Debug(msg string, fields ...zap.Field) {
	l.zapLogger.Debug(msg, fields...)
}

// Info logs an info message with optional fields
func (l *standardLogger) Info(msg string, fields ...zap.Field) {
	l.zapLogger.Info(msg, fields...)
}

// Warn logs a warning message with optional fields
func (l *standardLogger) Warn(msg string, fields ...zap.Field) {
	l.zapLogger.Warn(msg, fields...)
}

// Error logs an error message with optional fields
func (l *standardLogger) Error(msg string, fields ...zap.Field) {
	l.zapLogger.Error(msg, fields...)
}

// Fatal logs a fatal message and exits the program
func (l *standardLogger) Fatal(msg string, fields ...zap.Field) {
	l.zapLogger.Fatal(msg, fields...)
	os.Exit(1)
}

// LogEvent logs UberFX lifecycle events with structured logging
func (l *standardLogger) LogEvent(event fxevent.Event) {
	switch e := event.(type) {
	case *fxevent.OnStartExecuting:
		l.Debug("OnStart hook executing",
			zap.String("callee", e.FunctionName),
			zap.String("caller", e.CallerName),
		)
	case *fxevent.OnStartExecuted:
		if e.Err != nil {
			l.Error("OnStart hook failed",
				zap.String("callee", e.FunctionName),
				zap.String("caller", e.CallerName),
				zap.Error(e.Err),
			)
		} else {
			l.Debug("OnStart hook executed",
				zap.String("callee", e.FunctionName),
				zap.String("caller", e.CallerName),
				zap.String("runtime", e.Runtime.String()),
			)
		}
	case *fxevent.OnStopExecuting:
		l.Debug("OnStop hook executing",
			zap.String("callee", e.FunctionName),
			zap.String("caller", e.CallerName),
		)
	case *fxevent.OnStopExecuted:
		if e.Err != nil {
			l.Error("OnStop hook failed",
				zap.String("callee", e.FunctionName),
				zap.String("caller", e.CallerName),
				zap.Error(e.Err),
			)
		} else {
			l.Debug("OnStop hook executed",
				zap.String("callee", e.FunctionName),
				zap.String("caller", e.CallerName),
				zap.String("runtime", e.Runtime.String()),
			)
		}
	case *fxevent.Supplied:
		if e.Err != nil {
			l.Error("supplied",
				zap.Error(e.Err),
				zap.String("type", e.TypeName),
				zap.Strings("stacktrace", e.StackTrace),
			)
		} else {
			l.Debug("supplied",
				zap.String("type", e.TypeName),
			)
		}
	case *fxevent.Provided:
		if e.Err != nil {
			l.Error("provided",
				zap.Error(e.Err),
				zap.String("constructor", e.ConstructorName),
				zap.Strings("stacktrace", e.StackTrace),
			)
		} else {
			l.Debug("provided",
				zap.String("constructor", e.ConstructorName),
			)
		}
	case *fxevent.Replaced:
		if e.Err != nil {
			l.Error("replaced",
				zap.Error(e.Err),
				zap.Strings("stacktrace", e.StackTrace),
			)
		} else {
			l.Debug("replaced")
		}
	case *fxevent.Decorated:
		if e.Err != nil {
			l.Error("decorated",
				zap.Error(e.Err),
				zap.String("decorator", e.DecoratorName),
				zap.Strings("stacktrace", e.StackTrace),
			)
		} else {
			l.Debug("decorated",
				zap.String("decorator", e.DecoratorName),
			)
		}
	case *fxevent.Invoking:
		l.Debug("invoking",
			zap.String("function", e.FunctionName),
		)
	case *fxevent.Invoked:
		if e.Err != nil {
			l.Error("invoked",
				zap.Error(e.Err),
				zap.String("function", e.FunctionName),
				zap.String("stacktrace", e.Trace),
			)
		} else {
			l.Debug("invoked",
				zap.String("function", e.FunctionName),
			)
		}
	case *fxevent.Stopped:
		if e.Err != nil {
			l.Error("stopped",
				zap.Error(e.Err),
			)
		} else {
			l.Info("stopped")
		}
	case *fxevent.Started:
		if e.Err != nil {
			l.Error("started",
				zap.Error(e.Err),
			)
		} else {
			l.Info("started")
		}
	}
}
