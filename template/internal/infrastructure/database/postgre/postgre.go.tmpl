package postgre

import (
	"context"
	"fmt"

	"{{.Name}}/config"
	"{{.Name}}/pkg/logger"

	"go.uber.org/fx"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	gormLogger "gorm.io/gorm/logger"
)

type connection struct {
	DB     *gorm.DB
	logger logger.Logger
}

// PostgreDB defines the interface for database operations
type Connection interface {
	GetDB() *gorm.DB
	BeginTransaction(ctx context.Context) (*gorm.DB, error)
	ReleaseTransaction(ctx context.Context, tx *gorm.DB, err *error)
	CommitTransaction(ctx context.Context, tx *gorm.DB) error
	RollbackTransaction(ctx context.Context, tx *gorm.DB) error
}

func NewPostgreDB(config *config.Config, log logger.Logger) (*gorm.DB, error) {
	db, err := gorm.Open(postgres.New(
		postgres.Config{
			DSN: fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s",
				config.DB.Host, config.DB.User, config.DB.Password, config.DB.DBName, config.DB.Port, config.DB.SSLMode),
			PreferSimpleProtocol: true,
		},
	), &gorm.Config{
		Logger: gormLogger.Default.LogMode(gormLogger.Info),
	})

	if err != nil {
		log.WithError(err).Fatal("Failed to connect to database")
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	sqlDb, err := db.DB()
	if err != nil {
		log.WithError(err).Fatal("Failed to get DB from gorm")
		return nil, fmt.Errorf("failed to get DB from gorm: %w", err)
	}

	// Configure connection pool settings
	if config.DB.SetMaxIdleConns != 0 {
		sqlDb.SetMaxIdleConns(config.DB.SetMaxIdleConns)
	}
	if config.DB.SetMaxOpenConns != 0 {
		sqlDb.SetMaxOpenConns(config.DB.SetMaxOpenConns)
	}
	if config.DB.SetConnMaxLifetime != 0 {
		sqlDb.SetConnMaxLifetime(config.DB.SetConnMaxLifetime)
	}

	return db, nil
}

// NewPostgreDB creates a new PostgreSQL database connection
func NewConnection(db *gorm.DB, log logger.Logger) (Connection, error) {
	return &connection{DB: db, logger: log}, nil
}

// RunPostgreDB manages the database lifecycle
func RunPostgreDB(lc fx.Lifecycle, db *gorm.DB, log logger.Logger) {
	lc.Append(fx.Hook{
		OnStop: func(ctx context.Context) error {
			sqlDb, err := db.DB()
			if err != nil {
				log.WithError(err).Fatal("Failed to get DB from gorm")
				return fmt.Errorf("failed to get DB from gorm: %w", err)
			}
			return sqlDb.Close()
		},
	})
}

// BeginTransaction starts a new database transaction
func (d *connection) BeginTransaction(ctx context.Context) (*gorm.DB, error) {
	return d.DB.WithContext(ctx).Begin(), nil
}

// CommitTransaction commits the database transaction
func (d *connection) CommitTransaction(ctx context.Context, tx *gorm.DB) error {
	return tx.WithContext(ctx).Commit().Error
}

// GetDB returns the underlying GORM database instance
func (d *connection) GetDB() *gorm.DB {
	return d.DB
}

// ReleaseTransaction releases the database transaction
func (d *connection) ReleaseTransaction(ctx context.Context, tx *gorm.DB, err *error) {
	if *err != nil {
		d.RollbackTransaction(ctx, tx)
		d.logger.WithError(*err).Error("transaction failed, rolling back")
		return
	} else {
		tx.WithContext(ctx).Commit()
		d.logger.Info("transaction committed")
	}
}

// RollbackTransaction rolls back the database transaction
func (d *connection) RollbackTransaction(ctx context.Context, tx *gorm.DB) error {
	return tx.WithContext(ctx).Rollback().Error
}
