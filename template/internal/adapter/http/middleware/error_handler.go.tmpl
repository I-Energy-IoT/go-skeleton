package middleware

import (
	"net/http"
	"runtime/debug"

	"{{.Name}}/pkg/errors"
	"{{.Name}}/pkg/logger"
	"{{.Name}}/pkg/wrapper"

	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	"github.com/lib/pq"
)

type ErrorHandlerMiddleware struct {
	logger logger.Logger
}

func NewErrorHandlerMiddleware(logger logger.Logger) *ErrorHandlerMiddleware {
	return &ErrorHandlerMiddleware{logger: logger}
}

// ErrorHandlerMiddleware provides centralized error handling for HTTP requests
func (m *ErrorHandlerMiddleware) Middleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		defer func() {
			if err := recover(); err != nil {
				m.logger.WithContext(c.Request.Context()).
					WithError(err.(error)).
					WithFields(map[string]interface{}{
						"stack": string(debug.Stack()),
						"path":  c.Request.URL.Path,
						"method": c.Request.Method,
					}).
					Error("panic recovered")
				c.JSON(http.StatusInternalServerError, wrapper.NewErrorResponse(
					errors.NewInternalServerError("Internal server error"),
				))
			}
		}()

		c.Next()

		if len(c.Errors) > 0 {
			lastErr := c.Errors.Last()
			if lastErr == nil {
				return
			}
			err := lastErr.Err

			m.logger.WithContext(c.Request.Context()).
				WithError(err).
				WithFields(map[string]interface{}{
					"path":   c.Request.URL.Path,
					"method": c.Request.Method,
				}).
				Error("request error")

			// Handle different types of errors
			switch e := err.(type) {
			case *errors.AppError:
				c.JSON(e.Status, wrapper.NewErrorResponse(e))
			case validator.ValidationErrors:
				m.handleValidationErrors(c, e)
			case *pq.Error:
				m.handleDatabaseError(c, e)
			default:
				c.JSON(http.StatusInternalServerError, wrapper.NewErrorResponse(
					errors.NewInternalServerError("Internal server error"),
				))
			}
		}
	}
}

// handleValidationErrors processes validation errors
func (m *ErrorHandlerMiddleware) handleValidationErrors(c *gin.Context, err validator.ValidationErrors) {
	if len(err) > 0 {
		m.logger.WithContext(c.Request.Context()).
			WithError(err).
			WithFields(map[string]interface{}{
				"path":   c.Request.URL.Path,
				"method": c.Request.Method,
			}).
			Error("validation error")
		c.JSON(http.StatusBadRequest, wrapper.NewErrorResponse(
			errors.NewBadRequestError("validation error"),
		))
	} else {
		c.JSON(http.StatusBadRequest, wrapper.NewErrorResponse(
			errors.NewBadRequestError("invalid request"),
		))
	}
}

// handleDatabaseError processes database-specific errors
func (m *ErrorHandlerMiddleware) handleDatabaseError(c *gin.Context, err *pq.Error) {
	if err == nil {
		c.JSON(http.StatusInternalServerError, wrapper.NewErrorResponse(
			errors.NewInternalServerError("database error"),
		))
		return
	}

	switch err.Code {
	case "23505": // unique_violation
		c.JSON(http.StatusConflict, wrapper.NewErrorResponse(
			errors.NewConflictError("resource already exists"),
		))
	case "23503": // foreign_key_violation
		c.JSON(http.StatusBadRequest, wrapper.NewErrorResponse(
			errors.NewBadRequestError("invalid reference"),
		))
	default:
		m.logger.WithContext(c.Request.Context()).
			WithError(err).
			WithFields(map[string]interface{}{
				"code":   string(err.Code),
				"path":   c.Request.URL.Path,
				"method": c.Request.Method,
			}).
			Error("database error")
		c.JSON(http.StatusInternalServerError, wrapper.NewErrorResponse(
			errors.NewInternalServerError("database error"),
		))
	}
}
